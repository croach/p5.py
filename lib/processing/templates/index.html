<html>
<head>
    <style type="text/css">
        body {
            text-align: center;
		    background-color: #333;
        }
        canvas {
            border: 1px solid #444;
		    margin: 50px auto 0px 0px;
		    padding: 25px 15px 25px 15px;
		    background-color: #3d3d3d;
        }
    </style>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
    <script type="text/javascript">
    $(function() {
        var colors;
        var ws = new WebSocket("ws://localhost:{{ port }}/ws");

        function getCanvas(w, h) {
            var canvas = $("canvas")[0];
            if (typeof canvas === "undefined") {
                // Create a new canvas element if one doesn't already exist
                $("body").append('<canvas width="' + w + 'px" height="' + h + 'px">');
                canvas = $("canvas")[0];

                // Initialize the canvas element's defaults
                processingFns["stroke"].apply(canvas, [0, 0, 0]);
                processingFns["strokeWeight"].apply(canvas, [1]);
                processingFns["fill"].apply(canvas, [255, 255, 255]);
                processingFns["background"].apply(canvas, [230, 230, 230]);
            }
            return canvas;
        }

        function color(r, g, b, a) {
            var colorString = r + ", "+  g + ", " + b;
            if (a !== undefined) {
                colorString = "rgba(" + colorString + ", " + a/255 + ")";
            } else {
                colorString = "rgb(" + colorString + ")";
            }
            return colorString;
        }

        var processingFns = {

            point: function(x, y) {
                var ctx = this.getContext("2d");
                ctx.fillRect(x, y, 1, 1);
            },

            background: function(r, g, b, a) {
                var ctx = this.getContext("2d");
                ctx.save();
                ctx.fillStyle = color(r, g, b, a);
                ctx.fillRect(0, 0, this.width, this.height);
                ctx.restore();
            },

            fill: function(r, g, b, a) {
                var ctx = this.getContext("2d");
                ctx.fillStyle = color(r, g, b, a);
            },

            stroke: function(r, g, b, a) {
                var ctx = this.getContext("2d");
                ctx.strokeStyle = color(r, g, b, a);
            },

            noStroke: function() {
                var ctx = this.getContext("2d");
                ctx.strokeStyle = color(0, 0, 0, 0);
            },

            strokeWeight: function(weight) {
                var ctx = this.getContext("2d");
                ctx.lineWidth = weight;
            },

            line: function(x1, y1, x2, y2) {
                var ctx = this.getContext("2d");

                // Save the current state since we may have to change the line
                // width to make it match how line acts in Processing
                ctx.save();

                // The following bit of code gives us nice, crisp 1 pixel lines
                if (x1 === x2) {                             // vertical line
                    if (x1 === Math.floor(x1)) {
                        x1 = x2 = x1 - 0.5;
                    } else if (x1 < Math.floor(x1) + 0.5) {
                        x1 = x2 = Math.floor(x1) - 0.5;
                    } else {
                        x1 = x2 = Math.ceil(x1) - 0.5;
                    }
                    console.log(x1);
                } else if (y1 === y2) {                      // horizontal line
                    if (y1 === Math.floor(y1)) {
                        y1 = y2 = y1 - 0.5;
                    } else if (y1 < Math.floor(y1) + 0.5) {
                        y1 = y2 = Math.floor(y1) - 0.5;
                    } else {
                        y1 = y2 = Math.ceil(y1) - 0.5;
                    }
                    console.log(y1);
                // TODO: not quite sure why I need to add 0.5 to an odd sized diagonal line
                } else if (ctx.lineWidth % 2 === 1) {        // diagonal line
                    ctx.lineWidth += 0.5;
                }

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                // After drawing the line, restore the previous state
                ctx.restore();
            },

            rect: function(x, y, width, height) {
                var ctx = this.getContext("2d");
		        ctx.strokeRect(x, y, width, height);
                ctx.fillRect(x, y, width, height);
            },

            ellipse: function(x, y, width, height) {
                var ctx = this.getContext("2d");
                ctx.beginPath();

                // TODO: take ellipse mode into account when drawing the ellipse
                // Ellipse modes: CENTER (default), RADIUS, CORNER, CORNERS

                if (width === height) {
                    ctx.arc(x, y, width / 2, 0, 6.283185307179586, false);
                } else {
                    // TODO: oval code
                }

                ctx.stroke();
                ctx.fill();
            },

            _ellipseMode: "CENTER",
            ellipseMode: function(mode) {
                _ellipseMode = mode;
            }

        };

        ws.onmessage = function (evt) {
            var data = JSON.parse(evt.data),
                commands = data.commands,
                canvas = getCanvas(data.canvas.width, data.canvas.height),
                ctx = canvas.getContext("2d");

            for (var i = 0; i < commands.length; i++) {
                var command = commands[i];
                processingFns[command.name].apply(canvas, command.args);
            };
        };
    });
    </script>
</head>
<body>
</body>
</html>
